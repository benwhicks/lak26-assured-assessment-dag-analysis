---
title: "elicited-dag-analysis"
format: html
---

# Defining DAGs

``` {r}
library(tidyverse)
library(tidygraph)

# CD: Course Data (both LMS and Course structure)
# CD.Str Course structure (usually the course data on graphs)
# CD.LMS: LMS activity data
# S. Student attribute. Subsets S.Kn knowledge, S.Cp capabilities, S.Att attribute that is generally unchangible (i.e. gender)
# T. Teacher attribute
# LD. Learning design aspect
# H. Help of some kind. (i.e. assistance)
# Use S.Kn for student knowledge, but S.Kn.Att for a sub component of knowledge
# .Act means "action" or "activity", where people do things or make decisions.

# S.Att.SocCap - social capital
# T.Act.Integ - teacher (or student) acting with integrity (academic)
# LD.Task - assessment design quality
# T.RelMark - teacher reliable marking
# T/S.WrkLd - teacher / student workload
dag_s1 <- dagitty('dag S1 {
CD [pos="-0.228,0.457"]
Grade [outcome,pos="-0.830,0.442"]
H [pos="0.285,-0.845"]
LD.Task [pos="-0.408,-0.241"]
S.Act.Integ [pos="-0.202,-0.798"]
S.Att.SocCap [pos="-0.627,-1.067"]
S.Kn [exposure,pos="0.046,-0.298"]
S.WrkLd [pos="0.115,0.191"]
T.Act.Integ [pos="-0.748,-0.410"]
T.RelMark [pos="-1.079,-0.201"]
T.WrkLd [pos="-1.386,-0.453"]
H -> S.Kn
LD.Task -> CD
LD.Task -> T.RelMark
S.Act.Integ -> LD.Task
S.Att.SocCap -> H
S.Att.SocCap -> LD.Task
S.Att.SocCap -> T.Act.Integ
S.Att.SocCap -> T.RelMark
S.Kn -> LD.Task
S.Kn -> S.WrkLd
S.WrkLd -> Grade
T.Act.Integ -> LD.Task
T.Act.Integ -> T.RelMark
T.RelMark -> CD
T.RelMark -> Grade
T.WrkLd -> T.RelMark
}')
# plot(dag_s1)

# S.Act - student activity. Doing work
# T.Inst - teacher instruction (quality of)
# H.Peer - student peer learning / assistance
# T.Fb - teacher feedback
# S.SRL - student SRL

dag_s2 <- dagitty('dag S2 {
CD.LMS [pos="0.190,-0.154"]
CD.Str [pos="-1.216,-0.755"]
Grade [outcome,pos="-0.480,0.370"]
H.AI.evil [pos="-1.007,0.166"]
H.AI.good [pos="-1.043,-0.363"]
H.Peer [pos="-0.300,-0.561"]
H.Tut.Fb [pos="-1.245,-0.054"]
LD [pos="-0.670,-0.848"]
S.Act [pos="-0.608,-0.348"]
S.Cp.SRL [pos="-0.614,0.097"]
S.Kn [exposure,pos="-0.228,0.018"]
T.Inst [pos="0.073,-0.694"]
H.AI.evil -> Grade
H.AI.good -> CD.Str
H.AI.good -> S.Cp.SRL
H.AI.good -> S.Kn
H.Peer -> S.Kn
H.Tut.Fb -> H.AI.evil
H.Tut.Fb -> S.Cp.SRL
H.Tut.Fb -> S.Kn
LD -> CD.Str
LD -> H.AI.good
LD -> H.Peer
LD -> S.Act
LD -> T.Inst
S.Act -> CD.LMS
S.Act -> CD.Str
S.Act -> H.Tut.Fb
S.Act -> S.Cp.SRL
S.Act -> S.Kn
S.Cp.SRL -> Grade
S.Cp.SRL -> H.AI.evil
S.Kn -> Grade
S.Kn -> S.Cp.SRL
T.Inst -> S.Kn
}
')
# plot(dag_s2)

# T.KnSt - Teacher knowing students
# T.AIlit - Teacher AI literacy
# T.AIuse - Teacher AI use
# T.KnSub - Teacher subject knowledge
# S.Act - Student activity, doing the work. Was "S: Course Materials" on graph
# H.Tut - Help from the tutor
# H.SubC - Help from the subject coordinator
# S.Perf - Student performance on the task
# S.Kn.Aca - student academic skill

dag_s3 <- dagitty('dag S3 {
CD.LMS [pos="-0.156,0.899"]
CD.Str [pos="-1.134,0.874"]
Grade [outcome,pos="-0.670,0.870"]
H.AI [pos="0.472,-0.424"]
H.Peer [pos="-0.160,-0.215"]
H.Tut [pos="-0.003,-0.600"]
LD.Task [pos="-1.245,-0.050"]
S.Act [pos="-0.621,-0.571"]
S.Kn [exposure,pos="-0.706,-0.147"]
S.Kn.Aca [pos="0.305,0.083"]
S.Perf [pos="-0.660,0.370"]
T.AIuse [pos="-0.905,-0.032"]
T.Kn.AI [pos="-1.380,0.414"]
T.Kn.Ass [pos="-1.720,0.137"]
T.Kn.Sub [pos="-1.301,-0.830"]
T.KnStu [pos="-1.638,-0.366"]
H.AI -> H.Tut
H.AI -> S.Perf
H.Peer -> CD.LMS
H.Peer -> S.Kn
H.Peer -> S.Kn.Aca
H.Tut -> CD.LMS
H.Tut -> S.Kn
LD.Task -> CD.Str
LD.Task -> S.Perf
S.Act -> CD.LMS
S.Act -> S.Kn
S.Kn -> S.Perf
S.Kn.Aca -> S.Perf
S.Perf -> Grade
S.Perf -> H.Tut
T.AIuse -> LD.Task
T.Kn.AI -> LD.Task
T.Kn.Ass -> LD.Task
T.Kn.Sub -> H.Tut
T.Kn.Sub -> LD.Task
T.Kn.Sub -> S.Act
T.KnStu -> LD.Task
T.KnStu -> S.Kn
}')
# plot(dag_s3)

# S4

# CD.Att - attendance
# S.Kn.Fb - Student feedback literacy
# S.Kn.EvJdg - Student evaluative judgement
# S.Kn.Prior - Base / prior knowledge
# S.Kn - Knowledge to be measured at end of sub
# S.Aff.MindSet - Student affective state: Effort / willingness / learning mindset
# S.Act.Fb - Student acting / taking on feedback
# S.Act.Frm - Student working on formative tasks
# S.Lrn.Fb - Student learns from feedback
# S.Att.Nro - Student neurodivergent 
# S.Att.Hsk - Student attribute, help seeking

dag_s4 <- dagitty('dag S4 {
CD.Att [pos="-1.729,-0.248"]
CD.LMS [pos="-1.344,0.173"]
Grade [outcome,pos="-0.761,0.651"]
H.AI [pos="0.544,-0.025"]
H.Peer [pos="-0.016,-0.496"]
H.Tut [pos="-0.313,-0.694"]
S.Act.Fb [pos="-1.422,-0.686"]
S.Act.Frm [pos="-0.830,-0.686"]
S.Aff.MindSet [pos="-1.671,-1.290"]
S.Att.HSk [pos="0.292,-0.755"]
S.Att.Nro [pos="0.877,-1.078"]
S.Kn [exposure,pos="-0.889,-0.187"]
S.Kn.EvJdg [pos="-0.598,-1.261"]
S.Kn.Fb [pos="-1.026,-1.204"]
S.Kn.Prior [pos="0.014,-1.337"]
S.Lrn.Fb [pos="-0.408,-0.172"]
S.WrkLd [pos="0.436,-1.200"]
H.AI -> Grade
H.AI -> S.Lrn.Fb
H.Peer -> S.Lrn.Fb
H.Tut -> S.Kn
S.Act.Fb -> S.Act.Frm
S.Act.Frm -> CD.LMS
S.Act.Frm -> S.Kn
S.Aff.MindSet -> CD.Att
S.Aff.MindSet -> S.Act.Fb
S.Aff.MindSet -> S.Act.Frm
S.Att.HSk -> H.Peer
S.Att.HSk -> H.Tut
S.Att.Nro -> H.AI
S.Att.Nro -> S.Att.HSk
S.Kn -> Grade
S.Kn -> S.Act.Fb
S.Kn.EvJdg -> S.Act.Fb
S.Kn.EvJdg -> S.Act.Frm
S.Kn.EvJdg -> S.Lrn.Fb
S.Kn.Fb -> S.Act.Fb
S.Kn.Fb -> S.Act.Frm
S.Kn.Prior -> S.Act.Frm
S.Lrn.Fb -> S.Kn
S.WrkLd -> H.AI
S.WrkLd -> S.Act.Frm
}')
# plot(dag_s4)

# S.Lrn - Student Learns, in this case used for "knowledge retention"
# S.Aff.Safe - Student feels safe
# S.Aff.Joy - Student is enjoying learning
# S.Aff.MindSet - Student attitude towards learning - change effort above
dag_s5 <- dagitty('dag S5 {
Grade [outcome,pos="-0.480,1.039"]
Grade.Exam [pos="0.105,0.590"]
Grade.Proc [pos="-0.663,0.489"]
Grade.Quiz [pos="-0.323,0.439"]
Grade.Ref [pos="-0.935,0.618"]
H.AI.Agent [pos="-1.308,0.931"]
H.AI.Fb [pos="-1.442,0.618"]
H.AI.Res [pos="-1.252,0.316"]
H.AI.Study [pos="0.472,0.079"]
H.AI.evil [pos="0.563,1.140"]
H.Ment [pos="-0.729,-0.801"]
H.Tut [pos="-0.186,-0.852"]
S.Aff.Joy [latent,pos="-0.130,-0.579"]
S.Aff.MindSet [latent,pos="-0.882,-0.334"]
S.Aff.Safe [latent,pos="-1.111,-0.453"]
S.Kn [exposure,pos="-0.284,-0.223"]
S.Kn.Aca [pos="-0.542,0.054"]
S.Lrn [exposure,pos="-0.045,0.054"]
Grade.Exam -> Grade
Grade.Proc -> Grade
Grade.Quiz -> Grade
Grade.Ref -> Grade
H.AI.Agent -> Grade.Ref
H.AI.Fb -> Grade.Ref
H.AI.Res -> Grade.Ref
H.AI.Study -> S.Lrn
H.AI.evil -> Grade.Proc
H.AI.evil -> Grade.Quiz
H.AI.evil -> S.Lrn
H.Ment -> S.Aff.Joy
H.Ment -> S.Aff.MindSet
H.Ment -> S.Aff.Safe
H.Ment -> S.Kn.Aca
H.Tut -> S.Aff.Joy
H.Tut -> S.Aff.MindSet
H.Tut -> S.Kn
H.Tut -> S.Kn.Aca
S.Aff.Joy -> S.Lrn
S.Aff.MindSet -> Grade.Ref
S.Aff.MindSet -> S.Kn
S.Aff.MindSet -> S.Kn.Aca
S.Aff.MindSet -> S.Lrn
S.Aff.Safe -> S.Aff.MindSet
S.Kn -> Grade.Proc
S.Kn -> Grade.Quiz
S.Kn -> S.Lrn
S.Kn.Aca -> Grade.Exam
S.Kn.Aca -> Grade.Proc
S.Lrn -> Grade.Exam
}')
dag_s6 <- dagitty('dag S6 {
CD.LMS [pos="-0.081,-1.053"]
CD.Str [pos="-0.444,-1.085"]
Grade [outcome,pos="-0.604,0.363"]
H [pos="-0.850,-0.352"]
H.AI.evil [pos="-0.176,-0.305"]
H.AI.good [pos="-0.111,-0.751"]
LD.AIguide [pos="0.223,-0.607"]
LD.Task [pos="-0.817,-0.916"]
Post.Fb [pos="-1.366,-0.032"]
S.Act [pos="-0.617,-0.485"]
S.Act.Fb [pos="-0.454,-0.740"]
S.Att.Eq [pos="-1.275,-1.024"]
S.Kn [exposure,pos="-0.853,-0.690"]
S.Kn.Aca [pos="-1.000,-0.039"]
CD.Str -> LD.Task
Grade -> Post.Fb
H -> Grade
H -> H.AI.evil
H -> S.Kn.Aca
H.AI.evil -> Grade
H.AI.good -> CD.LMS
H.AI.good <-> S.Act
LD.AIguide -> H.AI.evil
LD.AIguide -> H.AI.good
LD.Task -> S.Kn
LD.Task <-> S.Att.Eq
Post.Fb -> S.Kn
Post.Fb -> S.Kn.Aca
S.Act -> Grade
S.Act -> S.Act.Fb
S.Act.Fb -> H.AI.evil
S.Act.Fb -> H.AI.good
S.Act.Fb -> S.Kn
S.Att.Eq -> H
S.Kn -> S.Act
S.Kn.Aca -> Grade
}
')

# S.Kn.Coms - communication skill knowledge / writing / presentation
# S.Kn.Tech - Technical knowledge
# S.Kn.Interp - Interpretation knowledge / skill
# S.Kn.Prior - THis is 'skill' on the original, changed to better match how it is described in other diagrams and this transcript
# S.Act.AIstrat - the student's use choice / strategy for using AI. Higher is a more moral choice. 

dag_s7 <- dagitty('dag S7 {
CD.Att [pos="-0.944,-0.114"]
CD.LMS [pos="-0.933,-0.204"]
CD.LMS.code [pos="-1.142,-0.011"]
CD.LMS.write [pos="-0.934,-0.005"]
Grade [outcome,pos="-1.046,0.161"]
Grade.Coms [pos="-1.045,0.059"]
Grade.Interp [pos="-0.989,0.061"]
Grade.Tech [pos="-1.091,0.057"]
H.AI.Fb [pos="-1.111,-0.190"]
H.AI.Study [pos="-1.124,-0.130"]
H.AI.evil.code [pos="-1.068,-0.011"]
H.AI.evil.write [pos="-1.012,-0.014"]
H.other.evil [pos="-0.969,-0.034"]
S.Act.AIstrat [pos="-1.059,-0.164"]
S.Act.Time [pos="-1.020,-0.165"]
S.Aff.MindSet [pos="-1.038,-0.282"]
S.Kn.Coms [exposure,pos="-1.042,-0.040"]
S.Kn.Interp [exposure,pos="-0.990,-0.068"]
S.Kn.Prior [pos="-0.977,-0.267"]
S.Kn.Tech [exposure,pos="-1.091,-0.066"]
S.WrkLd [pos="-1.087,-0.276"]
Grade.Coms -> Grade
Grade.Interp -> Grade
Grade.Tech -> Grade
H.AI.Fb -> S.Kn.Coms
H.AI.Fb -> S.Kn.Interp
H.AI.Study -> S.Kn.Tech
H.AI.evil.code -> CD.LMS.code
H.AI.evil.code -> Grade.Tech
H.AI.evil.write -> CD.LMS.write
H.AI.evil.write -> Grade.Coms
H.AI.evil.write -> Grade.Interp
H.other.evil -> CD.LMS.write
H.other.evil -> Grade
S.Act.AIstrat -> H.AI.Fb
S.Act.AIstrat -> H.AI.Study
S.Act.AIstrat -> H.AI.evil.code
S.Act.AIstrat -> H.AI.evil.write
S.Act.Time -> CD.Att
S.Act.Time -> CD.LMS
S.Act.Time -> H.other.evil
S.Act.Time -> S.Act.AIstrat
S.Aff.MindSet -> CD.LMS
S.Aff.MindSet -> H.other.evil
S.Aff.MindSet -> S.Act.AIstrat
S.Aff.MindSet -> S.Act.Time
S.Kn.Coms -> Grade.Coms
S.Kn.Coms <-> S.Kn.Interp
S.Kn.Interp -> Grade.Interp
S.Kn.Prior -> H.other.evil
S.Kn.Prior -> S.Kn.Coms
S.Kn.Prior -> S.Kn.Interp
S.Kn.Prior -> S.Kn.Tech
S.Kn.Tech -> Grade.Tech
S.Kn.Tech -> S.Kn.Interp
S.WrkLd -> S.Act.AIstrat
S.WrkLd -> S.Act.Time
}')


# S.SRL - using this, but was referred to as "individual capability" in the original
# S.GrpWrk - students' collaboration ability / capability

dag_s8 <- dagitty('dag S8 {
CD.LMS [pos="-1.617,-1.199"]
Grade [outcome,pos="-0.416,0.274"]
H [pos="0.345,-0.828"]
H.AI.Agent [pos="-0.520,-1.045"]
H.AI.evil [pos="-0.759,-0.884"]
H.Tut [pos="0.213,-1.306"]
LD.Task [pos="-1.134,-0.983"]
LD.Task.Code [pos="-1.867,-0.480"]
LD.Task.Grp [pos="-1.249,-0.224"]
LD.Task.Other [pos="-0.591,-0.662"]
LD.Task.Prac [pos="-1.460,-0.550"]
LD.Task.Write [pos="-1.152,-0.598"]
S.Cp.Grp [exposure,pos="-0.859,-0.142"]
S.Cp.Ind [exposure,pos="-0.405,-0.162"]
S.Kn [exposure,pos="0.166,-0.142"]
CD.LMS -> LD.Task.Code
CD.LMS -> LD.Task.Prac
CD.LMS -> LD.Task.Write
H -> S.Cp.Grp
H -> S.Cp.Ind
H -> S.Kn
H.AI.Agent -> CD.LMS
H.AI.Agent -> H
H.AI.evil -> H
H.AI.evil -> LD.Task
H.Tut -> CD.LMS
H.Tut -> H
LD.Task -> LD.Task.Code
LD.Task -> LD.Task.Prac
LD.Task -> LD.Task.Write
LD.Task.Code -> LD.Task.Grp
LD.Task.Grp -> S.Cp.Grp
LD.Task.Other -> S.Cp.Grp
LD.Task.Other -> S.Cp.Ind
LD.Task.Other -> S.Kn
LD.Task.Prac -> LD.Task.Grp
LD.Task.Write -> LD.Task.Grp
S.Cp.Grp -> Grade
S.Cp.Ind -> Grade
S.Kn -> Grade
}
')

```

``` {r}
dag_to_tidy_graph <- function(dag){
    # Extract edges
    edges <- as.data.frame( dagitty::edges(dag) )
    nodes <- tibble(name = unique(c(edges$v, edges$w)))

    # Build tidygraph
    tg <- tbl_graph(nodes = nodes, edges = edges, directed = TRUE)
    return(tg)
}
```

``` {r}
plot(dag_to_tidy_graph(dag_s1))
```

# Graph Metrics

``` {r}
equivalenceClass(dag_s1) |> plot() # This is Markov Equivalence if the same 
adjustmentSets(dag_s1)
igraph::is_isomorphic_to(dag_to_tidy_graph(dag_s1), dag_to_tidy_graph(dag_s1)) # ignores labels
igraph::subgraph_isomorphisms(dag_to_tidy_graph(dag_s1), dag_to_tidy_graph(dag_s1)) # Finds isomorphic subgraphs
```

## Graph operations 

### Node contraction

> What “merge nodes” can mean 
> There are two common interpretations:
> ### Graph contraction (strict)
> Take two nodes and fuse them into a single new node.
> All edges incident on either node are redirected to the new node.
> Self-loops are usually removed.
> ### Semantic merging in a causal model (coarsening variables)
> Conceptually treating two variables as indistinguishable, e.g. merging two survey questions into one construct.
> Same structural effect, but carries causal meaning (you’re collapsing state space).

``` {r}
tdag_s1 <- dag_to_tidy_graph(dag_s1)
tdag_s2 <- dag_to_tidy_graph(dag_s2)
tdag_s3 <- dag_to_tidy_graph(dag_s3)
tdag_s4 <- dag_to_tidy_graph(dag_s4)
tdag_s5 <- dag_to_tidy_graph(dag_s5)
tdag_s6 <- dag_to_tidy_graph(dag_s6)
tdag_s7 <- dag_to_tidy_graph(dag_s7)
tdag_s8 <- dag_to_tidy_graph(dag_s8)

tdag_s1 %N>% as_tibble()
```


Node summares

``` {r}
# exposures(dag_s1)
library(igraph)
library(dagitty)

g_edgelist <- function(g){ # g functions take tidygraph
    g %E>%
        as_tibble() %>%
        mutate(
            from = g %N>% pull(name) %>% .[from],
            to   = g %N>% pull(name) %>% .[to]
        ) %>%
        select(from, to)
}

g_merge_nodes <- function(g, regex_from, string_to, no.self.loops = TRUE) {
    g_el <- g_edgelist(g)
    g_el_m <- g_el |> 
        mutate(from = str_replace(from, regex_from, string_to),
               to = str_replace(to, regex_from, string_to)) |> 
        distinct()
    tbl_graph(edges = g_el_m)
}

g_merge_nodes(tdag_s2, "AI.*$", "AI") 

dag_merge_nodes <- function(dag, mapping) {
    # mapping is a named list, like: c("Old.var" = "Merged.var", "Old.var2" = "Merged.var")
    g <- graph_from_data_frame(dagitty::edges(dag))
    old_names <- V(g)$name
    # Replace names using mapping if present, else keep original
    new_names <- ifelse(old_names %in% names(mapping),
                        mapping[old_names],
                        old_names)
    V(g)$name <- unname(new_names)
    new_g <- simplify(g, remove.loops = TRUE, remove.multiple = TRUE)
    
    # Convert back to dagitty
    edges_m <- igraph::as_data_frame(new_g, what="edges")
    dag_str <- paste0("dag { ", paste0(edges_m$from, " -> ", edges_m$to, collapse="; "), " }")
    g_m <- dagitty(dag_str)
    g_m
}

g_summary_metrics <- function(g){
    graph_metrics <- list(
        order     = gorder(g), # number of nodes
        size      = gsize(g), # number of edges
        density   = edge_density(g),
        diameter  = diameter(g), # longest shortest path
        mean_path = mean_distance(g),
        clustering= transitivity(g, type = "global"),
        acyclic = igraph::is_acyclic(as.igraph(g))
    )
    graph_metrics
}

g_get_adjustment_sets <- function(g, exposure = "S.Kn", outcome = "Grade") {
    if (!is_acyclic(as.igraph(g))) {
        return(list("Cyclic" = "No adjustment sets"))
    }
  # Extract edges
  edges <- g_edgelist(g)
  
  # Build dagitty syntax
  edges_str <- edges %>%
    mutate(rel = paste0(from, " -> ", to)) %>%
    pull(rel)
  
  dagitty_str <- paste("dag {", paste(edges_str, collapse = "\n  "), "}", sep="\n")
  dagitty_obj <- dagitty(dagitty_str)
  
  # Compute adjustment sets
  sets <- adjustmentSets(dagitty_obj, exposure = exposure, outcome = outcome)
  as.list(sets)
}

g_get_adjustment_sets(tdag_s3)

g_summary_metrics(tdag_s2)
```

``` {r}
plot(tdag_s2)
plot(g_merge_nodes(tdag_s2, c("H.AI.good" = "H.AI", "H.AI.evil" = "H.AI")))
```

``` {r}





tdag_s2 %N>%
    mutate(
        degree_in = centrality_degree(mode = "in"),
        degree_out = centrality_degree(mode = "out"),
        betweenness = centrality_betweenness(), # Fraction of shortest paths between all node pairs that pass through the node
        centrality_eigen = centrality_eigen(scale = TRUE), # Node is important if it is connected to other important nodes
        centrality_pagerank = centrality_pagerank() # probability - sum to 1
    )

```





# Summarising a grpah:

Ideas:
- Complexity
- Complexity of adjustment sets